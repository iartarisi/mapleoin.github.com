<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Trocchi" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Trykker" rel="stylesheet" type="text/css">
<link rel="stylesheet" type="text/css" href="/css/style.css" />
<link rel="stylesheet" type="text/css" href="/css/pygments.css" />
<link rel="stylesheet" type="text/css" href="/css/archive.css" />
<link rel="shortcut icon" href="/favico.ico" />
<link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml" />
<title>Revolution blahg 
    | Mocking python's file open() builtin
</title>
</head>
<body>
<div id="container">
  <div id="header">
    <h1><a href="/" class="title">Revolution blahg</a></h1>
    <a href="/">home</a>
    <a href="/archive">archive</a>
    <a href="/about">about</a>
  </div>
<div id="content">
    <div class="post">
        <h2><a href="http://mapleoin.github.io/perma/mocking-python-file-open">Mocking python's file open() builtin</a></h2>
        <h3>Thursday, November 15, 2012</h3>
        <div class="entry">
            	<p>I was working on a method to read some proxy information from several files today and then I wanted to test it.</p>

	<p>A <em>very</em> simplified version (the original has all the different files being processed in different functions on different rules and it actually has error handling) of this function is this:</p>

<div class="Python"><div class="highlight"><pre><span class="n">SYS_PROXY</span> <span class="o">=</span> <span class="s1">&#39;/etc/sysconfig/proxy&#39;</span>
<span class="n">CURL_PROXY</span> <span class="o">=</span> <span class="s1">&#39;/root/.curlrc&#39;</span>
<span class="k">def</span> <span class="nf">get_proxy</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">SYS_PROXY</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;http_proxy&#39;</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">:</span>
            <span class="n">proxy</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;http_proxy = &#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
            <span class="k">if</span> <span class="n">proxy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">proxy</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">CURL_PROXY</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">if</span> <span class="s1">&#39;--proxy&#39;</span> <span class="ow">in</span> <span class="n">contents</span><span class="p">:</span>
            <span class="n">proxy</span> <span class="o">=</span> <span class="n">contents</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;--proxy &#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
            <span class="k">if</span> <span class="n">proxy</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">proxy</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s1">&#39;http_proxy&#39;</span><span class="p">)</span>
</pre></div>
</div>

	<p>As unit tests should be self-contained, they shouldn&#8217;t read any files on disk. So we need to mock them. I generally use Michael Foord&#8217;s <a href="http://www.voidspace.org.uk/python/mock/">mock</a>.</p>

	<p>In order to intercept calls to python&#8217;s <a href="http://docs.python.org/2/library/functions.html#open">open()</a>, we need to mock the <code>builtins.open</code> function:</p>

<div class="Python"><div class="highlight"><pre><span class="n">TEST_PROXY</span> <span class="o">=</span> <span class="s1">&#39;http://example.com:1111&#39;</span>
<span class="k">def</span> <span class="nf">test_proxy_url_in_sysproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">&quot;builtins.open&quot;</span><span class="p">,</span>
                    <span class="n">return_value</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s2">&quot;http_proxy = &quot;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">)):</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
</pre></div>
</div>

	<p>We&#8217;re good so far. Now we add the next natural test: we didn&#8217;t find anything in sysconfig, but we find the right proxy <span class="caps">URL</span> on our second try in <code>CURL_PROXY</code>:</p>

<div class="Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_proxy_url_not_in_sysproxy_but_in_yastproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">&quot;builtins.open&quot;</span><span class="p">,</span> <span class="n">return_value</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()):</span>
        <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">&quot;builtins.open&quot;</span><span class="p">,</span>
                        <span class="n">return_value</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39; --proxy &#39;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
</pre></div>
</div>

	<p>Urgh. That&#8217;s starting to look a bit clunky. It&#8217;s also wrong since the inner <code>with statement</code> ends up overriding the outer one and all we get for our second <code>open()</code> call is a <i>closed</i> file object:</p>

<pre>ValueError: I/O operation on closed file.
</pre>

	<p>Not to worry though. <code>mock</code> <a href="http://www.voidspace.org.uk/python/mock/mock.html#mock.Mock.side_effect">side_effect</a> have got us covered!</p>

<div class="Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_proxy_url_not_in_sysproxy_but_in_yastproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s2">&quot;builtins.open&quot;</span><span class="p">,</span>
                    <span class="n">side_effect</span><span class="o">=</span><span class="p">[</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(),</span>
                                 <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="s1">&#39; --proxy &#39;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">)]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
</pre></div>
</div>

	<p>The code looks cleaner now. A bit. And at least it works. But the list we pass in to <code>side_effect</code> makes another issue pop up. We now seem to be dependent on the order that the files are opened and read. That seems clunky. If we had to refactor our code to change the order that we read files in <code>get_proxy()</code> we would also had to change all our tests. Also it&#8217;s not quite obvious why we&#8217;re setting our return values as side effects.</p>

	<p>Ideally we&#8217;d have a way to assign each result to a filename and then not have to care about the order in which the files are open. In real life we would have two files with different contents anyway.</p>

	<p>So let&#8217;s implement that method. We, of course, want to make it a context manager.</p>

<div class="Python"><div class="highlight"><pre><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">mock_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">contents</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">mock_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s1">&#39;builtins.open&#39;</span><span class="p">,</span> <span class="n">mock_file</span><span class="p">):</span>
        <span class="k">yield</span>
</pre></div>
</div>

	<p>So we only intercept the filename that we want to mock and let everything else pass through to <code>builtins.open()</code>. The <code>yield</code> is there because a contextmanager should be a generator function. Everything before the <code>yield</code> gets executed when entering the <code>with mock_open ...</code> statement, then the content of the <code>with</code> block is executed and then everything after the <code>yield</code> in our mock_open function (there&#8217;s nothing there in our case).</p>

<div class="Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_proxy_url_not_in_sysproxy_but_in_yastproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">SYS_PROXY</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">CURL_PROXY</span><span class="p">,</span> <span class="s1">&#39; --proxy &#39;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
</pre></div>
</div>

	<p>Looks good.</p>

<pre>RuntimeError: maximum recursion depth exceeded in comparison
</pre>

	<p>Oops. It seems that we got into infinite recursion because we&#8217;re calling the mocked <code>open()</code> from the mocking function. We have to make sure that once we&#8217;ve mocked a call to <code>open()</code>, there&#8217;s no way we&#8217;re going to go through that mock again. Thankfully, the mock library provides methods to turn mocking on and off without using the <code>with mock.patch</code> context manager. Take a look at <code>mock.patch</code>&#8217;s <a href="http://www.voidspace.org.uk/python/mock/patch.html#patch-methods-start-and-stop">start and stop methods</a>.</p>

<div class="Python"><div class="highlight"><pre><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">mock_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">contents</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">mock_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="n">open_file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">open_file</span>
    <span class="n">mocked_file</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s1">&#39;builtins.open&#39;</span><span class="p">,</span> <span class="n">mock_file</span><span class="p">)</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">yield</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
</pre></div>
</div>

	<p>So we had to replace the <code>with mock.patch</code> statement with manually <code>start()</code>-ing and <code>stop()</code>-ing the mocking functionality before and after the <code>yield</code>. That&#8217;s basically what the <code>with</code> statement was doing, we just needed the indentifier so we can use it in the <code>else</code> branch.</p>

	<p>In the <code>else</code> branch we turn off the mocking before calling <code>open()</code> (that&#8217;s what was causing us to go in the infinite loop). After we&#8217;ve called <code>open()</code>, we go back to mocking <code>open()</code>, in case there will be a future call that we actually do want to mock.</p>

	<p>Test code now looks the same as before:</p>

<div class="Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_proxy_url_not_in_sysproxy_but_in_yastproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">SYS_PROXY</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">CURL_PROXY</span><span class="p">,</span> <span class="s1">&#39; --proxy &#39;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
</pre></div>
</div>

	<p>But this time it works. So we could all go home now.</p>

	<p>But say we wanted to ensure that no files were opened inside the <code>with mock_open</code> block other than the ones we mocked. It seems like a pretty sensible thing to do. Unit tests should be completely self-contained so you want to ensure they won&#8217;t be opening any files on the system. This would also catch some bugs that might only later pop-up on your CI server&#8217;s test runs, because of a custom development machine configuration.</p>

	<p>The problem is pretty simple if you use only one <code>with mock_open</code> block, but once you start using more than one nested contest managers you have a problem. You need to have a way to communicate between the different context-managers. Ideally you&#8217;d have a way for each context-manager to say to the others (after it&#8217;s finished processing): <em>hey, I finished my work here, but some dude opened a file which I didn&#8217;t mock. Did you mock it?</em>.</p>

	<p>So how do we solve that? We&#8217;ll use <code>global</code> variables! No. Just kidding.</p>

	<p>We&#8217;ll use exceptions. Simply make the inner statement raise a custom <code>NotMocked</code> exception and let the enclosing context managers catch.If none of the enclosing context managers mock the file that was opened in the inner block, they just let the user deal with the exception.</p>

	<p>So the exception can be a normal <code>Exception</code> subclass, but we need an extra bit of information, the <code>filename</code> that wasn&#8217;t mocked. I&#8217;ll also hardcode an error message in there:</p>

<div class="Python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NotMocked</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NotMocked</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="s2">&quot;The file </span><span class="si">%s</span><span class="s2"> was opened, but not mocked.&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
</pre></div>
</div>

	<p>The updated <code>mock_open</code> code looks like this:</p>

<div class="Python"><div class="highlight"><pre><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">mock_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">contents</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">complain</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">open_files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">mock_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
            <span class="n">open_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="n">mocked_file</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s1">&#39;builtins.open&#39;</span><span class="p">,</span> <span class="n">mock_file</span><span class="p">)</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">except</span> <span class="n">NotMocked</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">filename</span> <span class="o">!=</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">raise</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">open_file</span> <span class="ow">in</span> <span class="n">open_files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">complain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotMocked</span><span class="p">(</span><span class="n">open_file</span><span class="p">)</span>
</pre></div>
</div>

	<p>So we&#8217;re recording all the files that were opened in the <code>open_files</code> list. Then after all the code inside the <code>with</code> block was executed, we go through the <code>open_files</code> list and raise a <code>NotMocked</code> exception for each of those file names. We also added a new <code>complain</code> parameter just in case someone would like to turn this functionality off (maybe they want to use file fixtures after all).</p>

	<p>The StringIO objects now also have a <code>name</code> attribute. It&#8217;s a bit tricky to see why this is needed since at first sight those objects never get into the open_files list. But when we have nested <code>with mock_open</code> blocks the file returned by the <code>open()</code> function in <code>mock_file</code> might actually have been mocked by an enclosing context manager and its type would then be <code>StringIO</code>.</p>

	<p>The <code>try: except:</code> block around <code>yield</code> is for the enclosing context managers. When they get a <code>NotMocked</code> exception by running the code inside them, they check if it&#8217;s the file they&#8217;re mocking, in which case they ignore it. (Basically telling the nested context manager: <em>I&#8217;ve got you covered.</em>). If the <code>NotMocked</code> exception was raised on a file that&#8217;s different than the one they&#8217;re mocking, they simply re-raise it for someone else to deal with (either an enclosing context-manager) or the user.</p>

	<p>If we now added another <code>open()</code> call in our initial <code>get_proxy()</code> function, or inside the with statement in the test case,</p>

<div class="Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_proxy_url_not_in_sysproxy_but_in_yastproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">SYS_PROXY</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">CURL_PROXY</span><span class="p">,</span> <span class="s1">&#39; --proxy &#39;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
            <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;/dev/null&#39;</span><span class="p">)</span>
</pre></div>
</div>

	<p>we&#8217;d get this error:</p>

<pre>NotMocked: The file /dev/null was opened, but not mocked.
</pre>

	<p>Cool. Now how about the opposite? I had to refactor a lot of these test cases and at some point I wasn&#8217;t sure that all those assertions made sense. Was I really hitting all the files I had mocked? Well we could just add another check in our <code>mock_open()</code> code to see if all the files that were mocked, were actually accessed
 by the test code:</p>

<div class="Python"><div class="highlight"><pre><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">mock_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">contents</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">complain</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="n">open_files</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">mock_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">open_files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="n">mocked_file</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s1">&#39;builtins.open&#39;</span><span class="p">,</span> <span class="n">mock_file</span><span class="p">)</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">except</span> <span class="n">NotMocked</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">filename</span> <span class="o">!=</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">raise</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">open_files</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;The file </span><span class="si">%s</span><span class="s2"> was not opened.&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">open_files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">complain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotMocked</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
</pre></div>
</div>

	<p>We now track mocked files as <code>open_files</code>, too. Then at the end, we simply check if the file that we were supposed to be mocking (passed in as the <code>filename</code> argument) was indeed opened.</p>

	<p>The gotcha here is that we need to raise this exception before <code>NotMocked</code>, otherwise we risk the code not ever getting to the file-not-opened check. I guess this is where the difference between using exceptions when something exceptional occured vs. when you want to communicate with the enclosing function becomes obvious.</p>

	<p>If we now added another <code>mock_open</code> that we weren&#8217;t using to the test code:</p>

<div class="Python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">test_proxy_url_not_in_sysproxy_but_in_yastproxy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">SYS_PROXY</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="n">CURL_PROXY</span><span class="p">,</span> <span class="s1">&#39; --proxy &#39;</span> <span class="o">+</span> <span class="n">TEST_PROXY</span><span class="p">):</span>
            <span class="k">with</span> <span class="n">mock_open</span><span class="p">(</span><span class="s1">&#39;/dev/null&#39;</span><span class="p">):</span>
                <span class="n">get_proxy</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">assertEqual</span><span class="p">(</span><span class="n">TEST_PROXY</span><span class="p">,</span> <span class="n">get_proxy</span><span class="p">())</span>
</pre></div>
</div>

	<p>We&#8217;d get:</p>

<pre>AssertionError: The file /dev/null was not opened.
</pre>

	<p>EDIT: Eric Moyer found a bug (and suggested a fix) in this implementation. When the same file is opened multiple times, the <code>open_files</code> list will contain the filename multiple times, but it will only get <code>remove</code>-ed once. This can be easily solved by making the <code>open_files</code> list a set instead.</p>

	<p>So that&#8217;s about it, we now have a rock-solid <code>mock_open</code> function for mocking the builtin <code>open()</code>.</p>

	<p>Before we set it free, we need to add a nice docstring to it:</p>

<div class="Python"><div class="highlight"><pre><span class="nd">@contextmanager</span>
<span class="k">def</span> <span class="nf">mock_open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">contents</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">complain</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mock the open() builtin function on a specific filename</span>
<span class="sd">.</span>
<span class="sd">    Let execution pass through to open() on files different than</span>
<span class="sd">    :filename:. Return a StringIO with :contents: if the file was</span>
<span class="sd">    matched. If the :contents: parameter is not given or if it is None,</span>
<span class="sd">    a StringIO instance simulating an empty file is returned.</span>
<span class="sd">.</span>
<span class="sd">    If :complain: is True (default), will raise an AssertionError if</span>
<span class="sd">    :filename: was not opened in the enclosed block. A NotMocked</span>
<span class="sd">    exception will be raised if open() was called with a file that was</span>
<span class="sd">    not mocked by mock_open.</span>
<span class="sd">.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">open_files</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">mock_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">filename</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
            <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
        <span class="n">open_files</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f</span>
    <span class="n">mocked_file</span> <span class="o">=</span> <span class="n">mock</span><span class="o">.</span><span class="n">patch</span><span class="p">(</span><span class="s1">&#39;builtins.open&#39;</span><span class="p">,</span> <span class="n">mock_file</span><span class="p">)</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span>
    <span class="k">except</span> <span class="n">NotMocked</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">filename</span> <span class="o">!=</span> <span class="n">filename</span><span class="p">:</span>
            <span class="k">raise</span>
    <span class="n">mocked_file</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">open_files</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">complain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;The file </span><span class="si">%s</span><span class="s2"> was not opened.&quot;</span> <span class="o">%</span> <span class="n">filename</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">open_files</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">complain</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">NotMocked</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
</pre></div>
</div>
        </div>
        <div class="post_tags">Tags:
                <a href="/tag/programming.html">programming</a>
                <a href="/tag/python.html">python</a>
        </div>
        <br />
        <div id="disqus_thread"></div>
        <script>
    /*
    var disqus_config = function () {
        this.page.url = 'http://mapleoin.github.io/perma/mocking-python-file-open';
        this.page.identifier = 'mocking-python-file-open';
    };
    */
    (function() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//revolutionblahg.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
        </script>
        <noscript>Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="nofollow">
            comments powered by Disqus.</a>
        </noscript>
    </div>
</div>
<div style="clear: right;"></div>
</div><!-- container -->
<div id="smallprint"><a rel="license" href="https://creativecommons.org/licenses/by/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>.</div>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-5576939-1");
pageTracker._trackPageview();
} catch(err) {}</script>
</body>
</html>
